///정리///
npm i -g typescript
tsc --init
tsc 파일명

runtime error : 콘솔 안에서 일어나는 에러
이는 유저의 컴퓨터에서 코드가 실행될 때만 일어나는 에러일 수 있는데
이상적으로는 코드가 실행되기 전에 언어 자체적으로 알려주는 것이 좋다

타입스크립트는 강타입 프로그래밍 언어
작성한 코드가 자바스크립트로 변환(브라우저는 자바스크립트를 이해하기 때문)
변환 전에 에러 가능성을 감지

/*
1  let a = true;
2  let a : boolean = true;
*/
=> 결과는 같다
2처럼 명시적으로 적어주는 것보다 1처럼 하는 것이 좋다
더 쉽고 코드가 짧아져서 가독성이 좋아짐
그렇지만 값을 비워둘 때는 명시적으로 적자
/*
let a : number[] = [];
*/

/*
const player: {
    name: string,
    age?: number,
} = {
    name: "yoon",
}
*/
name은 필수지만 age는 ?를 붙였기 때문에 선택임

if(player.age < 10) => 오류 왜? player.age는 undefined일 수도 있기 때문
if(player.age && player.age < 10) => 정상

/*(첫글자는 대문자)
type Player = {
    name: string,
    age?: number,
}
*/
이렇게 해놓으면 여러번 작성 안 해도 됨
/*
const player1 : Player = {
    name:"",
}
*/

함수 예시
/*
function playerMaker(name: string){
    return {
        name:name
    }
}
*/
const player1 = playerMaker("yoon"); 정상
player1.age = 12; 오류 왜?
playerMaker 함수는 name만을 갖는 객체를 return하기 때문

/*
function playerMaker(name: string) : Player {
    ...
}
*/
이렇게 작성하면 return 값이 Player라는 것을 명시
화살표 함수로 작성 시
/*
const playerMaker = (name: string) : Player => ({name});
*/

자바스크립트에는 없지만 타입스크립트에서 사용할 수 있는 속성
'readonly' => 수정 불가
/* const a: readonly string = "hi"; */

/*
const player: [string, number, boolean] = [
    ....
]
*/
이렇게 하면 특정 위치에 특정 요소를 넣을 수 있다

any는 typescript에서 벗어나고 싶을 때 사용
/* const a : any[] = [...] */
typescript의 보호장치에서 벗어나기 때문에 권장 X

변수의 타입을 미리 알지 못 할 때 unknown 사용
/*
let a: unknown;

if(typeof a === 'number') let b = a + 1;
*/
변수의 타입이 unknown일 경우 확인 후 연산 가능

void는 아무것도 return하지 않는 함수를 대상으로 사용
/*
function hello(): void{
    console.log("hello");
}
*/
return이 없으면 typescript가 감지 그래서 void 꼭 안 써도 됨

never는 함수가 절대 return하지 않을 때 사용
/*
function hello(): never{
    throw new Error("xxx");
}
*/
=> return하지 않고 오류를 발생시키는 함수로 만들 수 있다

/*
function hello(name: string|number){
    if(typeof name === "string"){
        name // 타입: string
    } else if (typeof name === "number"){
        name // 타입: number
    } else {
        name // 타입: never 실행되면 안 됨
    }
}
*/

함수의 call signature 타입을 만들 수 있다
call signature? 함수가 인자로 무엇을 받고 무엇을 반환하는지 알려주는 것

/*
type Add = (a: number, b: number) => number;

//같은 거
type Add = {
    (a: number, b: number) :number
}

const add:Add = (a, b) => a + b;
*/

overloading?
보통 다른 사람들이 만든 외부 라이브러리를 사용하는데 이런 패키지나
라이브러리는 오버로딩을 많이 사용함

오버로딩은 함수가 서로 다른 여러개의 call signatures를 가지고 있을 때 발생
예시
/*
//Nextjs에서 사용하는 실제 예시
Router.push({
    path: "/home",
    state: 1
})

.push("/home")
*/
string 혹은 obj로 가능
해결법
/*
type Config = {
    path: string,
    state: object
}

type Push = {
    (path: string): void
    (config: Config): void
}

const push: Push = (config) => {
    if(typeof config === "string) ...
    ...
}
*/

타입이 아닌 파라미터의 개수가 다를 때?
/*
type Add = {
    (a: number, b: number) :number,
    (a: number, b: number, c: number): number,
}

const add: Add = (a, b, c?: number) => {
    if(c) return a + b + c;
    return a + b;
}
*/

다향성(polymorphism)? generic?
call signature를 작성 시 들어올 확실한 타입을 모를 때 generic 사용
/*
type SuperPrint = {
    <T>(a: T[]): T
}

const superPrint: SuperPrint = (a) => a[0];

//같은 거
function superPrint<T>(a: T[])l{
    return a[0];
}
*/
타입스크립트가 입력값을 보고 call signature를 생성
any는 에러 발생 가능 그래서 any 안 쓰고 generic 사용
제네릭 이름은 마음대로 설정 가능(단, 대문자로 시작)

/*
type Player<E> = {
    name: string
    extraInfo: E
}

const nico: Player<{favFood: string}> = {
    name: "nico",
    extraInfo: {
        favFood: "kimchi"
    }
}
*/

추상 클래스? 오직 다른 곳에서 상속받을 수 있는 클래스
직접 새로운 인스턴스를 만들 수는 없다

추상메소드는 추상 클래스를 상속받는 모든 것들이 구현해야 하는 메소드를 의미
추상메소드는 구현이 되어있지 않은 메소드 call signature만 가지고 있다
추상메소드가 있는 경우 추상 클래스를 상속받는 클래스에서 추상 메소드를 구현해야 함


다른 자식 클래서에서 필드를 사용하고 싶다면 private이 아닌 protected를 사용
외부에서는 보호받지만 상속된 인스턴스에서는 사용 가능


/*
type Words = {
    [key: string]: string
}
*/
Words 타입이 string만을 property로 가지는 오브젝트라는 것
이렇게 사용하면 제한된 property 혹은 key를 가지는 타입을 정의해주는 방법

/*
class Dict{
    private words: Words
    constructor(){
        this.words = {}
    }
    add(word: Word){
        ...
    }
}
*/
property가 constructor부터 바로 초기화되지 않음 => 수동으로 초기화
클래스를 타입처럼 사용 가능

타입을 콘크리트 타입이 아닌 사용자 지정 가능
/*
type Team = "red" | "blue" | "yellow"

type Player = {
    team: Team,
    ..
}
*/

인터페이스는 오직 한가지 용도만을 가지고 있다
오브젝트의 모양을 특정해주는 것 => 타입이 더 많은 기능을 할 수 있다
인터페이스는 같은 인터페이스에 다른 이름을 가진 property들을 쌓을 수 있다
인터페이스는 컴파일 하면 js로 바뀌지 않고 사라짐
인터페이스를 상속할 때 extends가 아닌 implements를 사용하면 코드가 더
가벼워짐(파일 사이즈가 작아짐)
(추상 클래스 상속 X => 인터페이스 상속 O)
인터페이스를 상속할 때에는 property를 private으로 사용 불가
인터페이스도 타입으로 사용 가능

클래스나 오브젝트의 모양을 정의하고 싶으면 인터페이스, 그 외 모든 경우 type사용

