///정리///
npm i -g typescript
tsc --init

runtime error : 콘솔 안에서 일어나는 에러
이는 유저의 컴퓨터에서 코드가 실행될 때만 일어나는 에러일 수 있는데
이상적으로는 코드가 실행되기 전에 언어 자체적으로 알려주는 것이 좋다

타입스크립트는 강타입 프로그래밍 언어
작성한 코드가 자바스크립트로 변환(브라우저는 자바스크립트를 이해하기 때문)
변환 전에 에러 가능성을 감지

/*
1  let a = true;
2  let a : boolean = true;
*/
=> 결과는 같다
2처럼 명시적으로 적어주는 것보다 1처럼 하는 것이 좋다
더 쉽고 코드가 짧아져서 가독성이 좋아짐
그렇지만 값을 비워둘 때는 명시적으로 적자
/*
let a : number[] = [];
*/

/*
const player: {
    name: string,
    age?: number,
} = {
    name: "yoon",
}
*/
name은 필수지만 age는 ?를 붙였기 때문에 선택임

if(player.age < 10) => 오류 왜? player.age는 undefined일 수도 있기 때문
if(player.age && player.age < 10) => 정상

/*(첫글자는 대문자)
type Player = {
    name: string,
    age?: number,
}
*/
이렇게 해놓으면 여러번 작성 안 해도 됨
/*
const player1 : Player = {
    name:"",
}
*/

함수 예시
/*
function playerMaker(name: string){
    return {
        name:name
    }
}
*/
const player1 = playerMaker("yoon"); 정상
player1.age = 12; 오류 왜?
playerMaker 함수는 name만을 갖는 객체를 return하기 때문

/*
function playerMaker(name: string) : Player {
    ...
}
*/
이렇게 작성하면 return 값이 Player라는 것을 명시
화살표 함수로 작성 시
/*
const playerMaker = (name: string) : Player => ({name});
*/

자바스크립트에는 없지만 타입스크립트에서 사용할 수 있는 속성
'readonly' => 수정 불가
/* const a: readonly string = "hi"; */

/*
const player: [string, number, boolean] = [
    ....
]
*/
이렇게 하면 특정 위치에 특정 요소를 넣을 수 있다

any는 typescript에서 벗어나고 싶을 때 사용
/* const a : any[] = [...] */
typescript의 보호장치에서 벗어나기 때문에 권장 X

변수의 타입을 미리 알지 못 할 때 unknown 사용
/*
let a: unknown;

if(typeof a === 'number') let b = a + 1;
*/
변수의 타입이 unknown일 경우 확인 후 연산 가능

void는 아무것도 return하지 않는 함수를 대상으로 사용
/*
function hello(): void{
    console.log("hello");
}
*/
return이 없으면 typescript가 감지 그래서 void 꼭 안 써도 됨

never는 함수가 절대 return하지 않을 때 사용
/*
function hello(): never{
    throw new Error("xxx");
}
*/
=> return하지 않고 오류를 발생시키는 함수로 만들 수 있다

/*
function hello(name: string|number){
    if(typeof name === "string"){
        name // 타입: string
    } else if (typeof name === "number"){
        name // 타입: number
    } else {
        name // 타입: never 실행되면 안 됨
    }
}
*/

함수의 call signature 타입을 만들 수 있다
call signature? 함수가 인자로 무엇을 받고 무엇을 반환하는지 알려주는 것

/*
type Add = (a: number, b: number) => number;

//같은 거
type Add = {
    (a: number, b: number) :number
}

const add:Add = (a, b) => a + b;
*/

overloading?
보통 다른 사람들이 만든 외부 라이브러리를 사용하는데 이런 패키지나
라이브러리는 오버로딩을 많이 사용함

오버로딩은 함수가 서로 다른 여러개의 call signatures를 가지고 있을 때 발생
예시
/*
//Nextjs에서 사용하는 실제 예시
Router.push({
    path: "/home",
    state: 1
})

.push("/home")
*/
string 혹은 obj로 가능
해결법
/*
type Config = {
    path: string,
    state: object
}

type Push = {
    (path: string): void
    (config: Config): void
}

const push: Push = (config) => {
    if(typeof config === "string) ...
    ...
}
*/

타입이 아닌 파라미터의 개수가 다를 때?
/*
type Add = {
    (a: number, b: number) :number,
    (a: number, b: number, c: number): number,
}

const add: Add = (a, b, c?: number) => {
    if(c) return a + b + c;
    return a + b;
}
*/

다향성(polymorphism)? generic?
call signature를 작성 시 들어올 확실한 타입을 모를 때 generic 사용
/*
type SuperPrint = {
    <T>(a: T[]): T
}

const superPrint: SuperPrint = (a) => a[0];

//같은 거
function superPrint<T>(a: T[])l{
    return a[0];
}
*/
타입스크립트가 입력값을 보고 call signature를 생성
any는 에러 발생 가능 그래서 any 안 쓰고 generic 사용
제네릭 이름은 마음대로 설정 가능(단, 대문자로 시작)

/*
type Player<E> = {
    name: string
    extraInfo: E
}

const nico: Player<{favFood: string}> = {
    name: "nico",
    extraInfo: {
        favFood: "kimchi"
    }
}
*/